"""Utilities for managing ordered image-processing pipelines."""

from __future__ import annotations

import copy
import logging
from dataclasses import dataclass, field
from typing import Any, Callable, Dict, Iterable, List, Optional

import numpy as np


LOGGER = logging.getLogger(__name__)


@dataclass
class PipelineStep:
    """Represents a single processing step within a pipeline.

    Parameters
    ----------
    name:
        Human readable identifier for the step. Used for serialisation and UI.
    function:
        Callable that accepts an ``np.ndarray`` and returns a processed copy.
    enabled:
        Flag controlling whether the step should be executed when applying the
        pipeline.
    params:
        Keyword arguments that will be forwarded to ``function`` during
        execution. The parameters are stored so they can be serialised to disk
        and restored later.
    """

    name: str
    function: Callable[..., np.ndarray]
    enabled: bool = True
    params: Dict[str, Any] = field(default_factory=dict)

    def apply(self, image: np.ndarray) -> np.ndarray:
        """Execute the step against ``image`` if it is enabled."""

        if not self.enabled:
            LOGGER.debug("Skipping disabled step: %s", self.name)
            return image
        LOGGER.debug("Applying step '%s' with params %s", self.name, self.params)
        return self.function(image, **self.params)

    def clone(self) -> "PipelineStep":
        """Return a lightweight copy of the step preserving the function."""

        return PipelineStep(
            name=self.name,
            function=self.function,
            enabled=self.enabled,
            params=copy.deepcopy(self.params),
        )

    def to_dict(self) -> Dict[str, Any]:
        """Serialise the step into a JSON friendly structure."""

        return {"name": self.name, "enabled": self.enabled, "params": copy.deepcopy(self.params)}

    @classmethod
    def from_dict(
        cls,
        data: Dict[str, Any],
        function_resolver: Callable[[str], Callable[..., np.ndarray]],
    ) -> "PipelineStep":
        """Create a :class:`PipelineStep` from a serialised representation.

        Parameters
        ----------
        data:
            Dictionary containing the fields generated by :meth:`to_dict`.
        function_resolver:
            Callback that accepts the step name and returns the processing
            callable. A :class:`KeyError` will be raised if the function cannot
            be resolved.
        """

        function = function_resolver(data["name"])
        return cls(
            name=data["name"],
            function=function,
            enabled=bool(data.get("enabled", True)),
            params=copy.deepcopy(data.get("params", {})),
        )


@dataclass
class PipelineHistoryEntry:
    """Snapshot of the pipeline configuration and output for undo/redo."""

    steps: List[PipelineStep]
    output: Optional[np.ndarray]

    def clone(self) -> "PipelineHistoryEntry":
        return PipelineHistoryEntry([step.clone() for step in self.steps], None if self.output is None else self.output.copy())


class PipelineManager:
    """Manage an ordered collection of :class:`PipelineStep` instances.

    The manager keeps track of undo/redo history and provides helpers for
    serialising the pipeline configuration for persistence.
    """

    def __init__(self, steps: Optional[Iterable[PipelineStep]] = None) -> None:
        self.steps: List[PipelineStep] = list(steps or [])
        self._undo_stack: List[PipelineHistoryEntry] = []
        self._redo_stack: List[PipelineHistoryEntry] = []

    # ------------------------------------------------------------------
    # Step management helpers
    # ------------------------------------------------------------------
    def add_step(self, step: PipelineStep, index: Optional[int] = None) -> None:
        """Append ``step`` to the pipeline or insert at ``index``."""

        if index is None:
            LOGGER.debug("Appending step '%s'", step.name)
            self.steps.append(step)
        else:
            LOGGER.debug("Inserting step '%s' at index %s", step.name, index)
            self.steps.insert(index, step)

    def remove_step(self, index: int) -> PipelineStep:
        """Remove and return the step located at ``index``."""

        step = self.steps.pop(index)
        LOGGER.debug("Removed step '%s' at index %s", step.name, index)
        return step

    def move_step(self, old_index: int, new_index: int) -> None:
        """Move the step from ``old_index`` to ``new_index`` preserving order."""

        step = self.steps.pop(old_index)
        self.steps.insert(new_index, step)
        LOGGER.info(
            "Moved step '%s' from %s to %s", step.name, old_index, new_index
        )

    def swap_steps(self, index_a: int, index_b: int) -> None:
        """Swap the steps at ``index_a`` and ``index_b``."""

        self.steps[index_a], self.steps[index_b] = self.steps[index_b], self.steps[index_a]
        LOGGER.info(
            "Swapped steps '%s' and '%s'", self.steps[index_a].name, self.steps[index_b].name
        )

    def set_step_enabled(self, identifier: int | str, enabled: bool) -> None:
        """Enable or disable a step referenced by index or name."""

        step = self._resolve_step(identifier)
        if step.enabled == enabled:
            return
        step.enabled = enabled
        LOGGER.info("Step '%s' %s", step.name, "enabled" if enabled else "disabled")

    def toggle_step(self, identifier: int | str) -> None:
        step = self._resolve_step(identifier)
        step.enabled = not step.enabled
        LOGGER.info("Toggled step '%s' -> %s", step.name, step.enabled)

    def get_step(self, identifier: int | str) -> PipelineStep:
        """Return the step referenced by ``identifier`` without mutation."""

        return self._resolve_step(identifier)

    def _resolve_step(self, identifier: int | str) -> PipelineStep:
        if isinstance(identifier, int):
            return self.steps[identifier]
        for step in self.steps:
            if step.name == identifier:
                return step
        raise KeyError(f"No pipeline step named '{identifier}'")

    # ------------------------------------------------------------------
    # History management
    # ------------------------------------------------------------------
    def _snapshot_steps(self) -> List[PipelineStep]:
        return [step.clone() for step in self.steps]

    def push_history(self, output: Optional[np.ndarray]) -> None:
        """Record the current pipeline configuration and ``output``."""

        entry = PipelineHistoryEntry(self._snapshot_steps(), None if output is None else output.copy())
        self._undo_stack.append(entry)
        self._redo_stack.clear()
        LOGGER.info("History push (undo depth=%s)", len(self._undo_stack))

    def clear_history(self) -> None:
        self._undo_stack.clear()
        self._redo_stack.clear()
        LOGGER.debug("Pipeline history cleared")

    def undo(self, current_output: Optional[np.ndarray]) -> Optional[PipelineHistoryEntry]:
        """Restore the previous state from the undo stack."""

        if not self._undo_stack:
            LOGGER.debug("Undo requested but stack empty")
            return None
        self._redo_stack.append(
            PipelineHistoryEntry(self._snapshot_steps(), None if current_output is None else current_output.copy())
        )
        entry = self._undo_stack.pop()
        self.steps = [step.clone() for step in entry.steps]
        LOGGER.info("Undo applied (remaining undo depth=%s)", len(self._undo_stack))
        return entry.clone()

    def redo(self, current_output: Optional[np.ndarray]) -> Optional[PipelineHistoryEntry]:
        """Restore the next state from the redo stack."""

        if not self._redo_stack:
            LOGGER.debug("Redo requested but stack empty")
            return None
        self._undo_stack.append(
            PipelineHistoryEntry(self._snapshot_steps(), None if current_output is None else current_output.copy())
        )
        entry = self._redo_stack.pop()
        self.steps = [step.clone() for step in entry.steps]
        LOGGER.info("Redo applied (remaining redo depth=%s)", len(self._redo_stack))
        return entry.clone()

    def can_undo(self) -> bool:
        return bool(self._undo_stack)

    def can_redo(self) -> bool:
        return bool(self._redo_stack)

    # ------------------------------------------------------------------
    # Execution and serialisation helpers
    # ------------------------------------------------------------------
    def apply(self, image: np.ndarray) -> np.ndarray:
        """Execute the pipeline against ``image`` returning the processed copy."""

        processed = image.copy()
        for step in self.steps:
            processed = step.apply(processed)
        return processed

    def get_order(self) -> List[str]:
        return [step.name for step in self.steps]

    def to_dict(self) -> Dict[str, Any]:
        """Serialise the pipeline configuration."""

        return {"steps": [step.to_dict() for step in self.steps]}

    @classmethod
    def from_dict(
        cls,
        data: Dict[str, Any],
        function_registry: Dict[str, Callable[..., np.ndarray]] | Callable[[str], Callable[..., np.ndarray]],
    ) -> "PipelineManager":
        """Recreate a manager from :meth:`to_dict` output.

        ``function_registry`` can either be a mapping or a callable. When a
        step cannot be resolved a warning is logged and the step is skipped.
        """

        if callable(function_registry):
            resolver = function_registry
        else:
            resolver = function_registry.__getitem__

        steps: List[PipelineStep] = []
        for item in data.get("steps", []):
            try:
                steps.append(PipelineStep.from_dict(item, resolver))
            except KeyError:
                LOGGER.warning("Unknown pipeline step '%s' skipped during load", item.get("name"))
        return cls(steps)

    # ------------------------------------------------------------------
    # Introspection helpers used by UIs
    # ------------------------------------------------------------------
    def iter_steps(self) -> Iterable[PipelineStep]:
        return iter(self.steps)

    def __len__(self) -> int:  # pragma: no cover - container convenience
        return len(self.steps)

    def __iter__(self):  # pragma: no cover - container convenience
        return iter(self.steps)

